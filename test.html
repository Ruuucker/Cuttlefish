<!DOCTYPE html>
<html>
    <head>
        <title>VivaGraphs constant layout demo page</title>
        <script src="libs/vivagraph.js"></script>

        <script type='text/javascript'>
            "use strict";

            function loadJSON(callback, path) {   
              console.log(path);
              var xobj = new XMLHttpRequest();
              xobj.overrideMimeType("application/json");
              xobj.open('GET', path, true);
              xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                  callback(JSON.parse(xobj.responseText));
                }
              };
              xobj.send(null);  
            }

            function onLoad() {

                /*
                Тут довольно ужасный код, но он принес мне немного боли поэтому пока что оставлю так
                Возможно перейду на
                https://gojs.net/latest/index.html

                TODO Решить баг с первинчым линком на графе

		Here is how it going to be:
		global circle
		for (host in hosts) {
			// Getting hops and traceroute
			let hops = hosts.hops;
			let trace = hosts.trace;

			if (traceroute info exist) { // По идее такая информация всегда должна существовать
				let prevNode = что-то;
				let hops = [массив извесных (не анонимных) хостов, являющиеся хопами];
				let ttls = кол-во хопов до цели;
				for (ttl in range of (1, max(ttls) + 1)) {
					if (ttl in ttls) {
						// Ищем хоп по ттл
						let hop = find_hop_by_ttl(hops, ttl);
						// И если ноды нет в кэше, создавать ли его я еще подумаю
						if (node is None) {
							// Рисуем ноду
						}
					}
					else {
						// Добавление анонимной ноды, но только если у нас нет о ней информации (такая как такая же дистанция, например)
						// Я не знаю зачем это, потом узнаю
						pre_hop = None
						pre_hop_distance = 0
						for i in range(1, ttl + 1) {
							pre_hop = find_hop_by_ttl(hops, ttl - i)
							if pre_hop is not None:
								pre_hop_distance = i
						                break
						}
						
						pre_hop = None
						pre_hop_distance = 0                        
						for i in range(1, ttl + 1) {                   
							pre_hop = find_hop_by_ttl(hops, ttl - i)                    
							if pre_hop is not None:                            
								pre_hop_distance = i                        
								break              
						}
						let parent_key = (pre_hop["ipaddr"], pre_hop_distance)
						let child_key = None;

						if (post_hop in not None) {
							child_key = (pre_hop["ipaddr"], post_hop_distance)
						}
						if (parent_key in parent_key_cache) {
							let node = ancestor_node_cache[child_key];
						} elif (child_key in not None && child_key in child_key_cache) {
							node = child_key_cache[child_key];
							graph.addLink(node, prevNode);
						} else {
							// Рисую ноду
							//graph.addLink();slkdjfksjd
							if (child_key is not None)
								child_key_cache[child_key] = node;
						}

					}
					prevNode = node;
				}
			}
		}
                */

                function drawHops (host) {
                    let prevNode = '127.0.0.1';
                    if (typeof host.trace == 'undefined') {
                        let tmpLocalhost = graph.getNode('127.0.0.1');
                    	// Here i can change the localhost ip
			tmpLocalhost.nodeId = host.address._attributes.addr;
                    }
                    else {

                        console.log(host.trace.hop);
                        if (typeof host.trace.hop.length == 'undefined') {
                            console.log('this is 1 hop');



                            graph.addLink(prevNode, host.trace.hop._attributes.ipaddr);

                            // Пиним ноду
                            let middle = graph.getNode(prevNode);
                            layout.pinNode(middle, true);
                            //prevNode = hop.ipaddr;
                        }
                        else {
                            for (let ii = 0; ii < host.trace.hop.length; ii++) {
                                
                                let hop = host.trace.hop[ii]._attributes;
                                // console.log('NEW HOP');
                                console.log(hop.ipaddr);
                                
                                // Тут делаю коннект этой ноды с предидущей
                                // let wtf = ii + Math.random();
                                // console.log(prevNode, hop.ipaddr);
                                graph.addLink(prevNode, hop.ipaddr);

                                prevNode = hop.ipaddr;
                             
                                // Пиним ноду
                                // let middle = graph.getNode(prevNode);
                                // layout.pinNode(middle, true);
                            }
                        }
                    }
                }

                var graph = Viva.Graph.graph();
                var layout = Viva.Graph.Layout.forceDirected(graph, {
                    springLength: 1200,
                    springCoeff : 0.0018,
                    gravity : -20,
                    // This is the main part of this example. We are telling force directed
                    // layout, that we want to change length of each physical spring
                    // by overriding `springTransform` method:
                    springTransform: function (link, spring) {
                      spring.length = 300;
                    }
                });

                var graphics = Viva.Graph.View.svgGraphics(),
                    nodeSize = 20;

                var renderer = Viva.Graph.View.renderer(graph, {
                        layout   : layout,
                        graphics : graphics,
                });

                graphics.node(function(node) {
                  var ui = Viva.Graph.svg('g'),
                      // Create SVG text element with user id as content
                      svgText = Viva.Graph.svg('text').attr('y', '-4px').text(node.id),
                      img = Viva.Graph.svg('image')
                         .attr('width', nodeSize)
                         .attr('height', nodeSize)
                         .link('http://localhost:8080/image');

                    ui.append(svgText);
                    ui.append(img);
                    return ui;

                }).placeNode(function(nodeUI, pos) {
                    nodeUI.attr('transform',
                                'translate(' +
                                      (pos.x - nodeSize/2) + ',' + (pos.y - nodeSize/2) +
                                ')');
                });


                loadJSON(function(arrayOfJSON) {
                    // Тут в теории можно сделать цикл реквестов всех сканов по типу
                    for (let ni = 0; ni < arrayOfJSON.length; ni++) {
                        loadJSON(function(nmapOutputJSON) {
                            console.log(nmapOutputJSON);

                            if (typeof nmapOutputJSON.nmaprun.host.length == 'undefined') {
                                let host = nmapOutputJSON.nmaprun.host;
                                drawHops (host);
                            }
                            else {

                                graph.addNode('127.0.0.1');
                                for (let i = 0; i < nmapOutputJSON.nmaprun.host.length; i++) {
                                    // console.log(nmapOutputJSON.nmaprun.host[i]);
                                    // nmapOutputJSON[i]
                                    let host = nmapOutputJSON.nmaprun.host[i];
                                    drawHops (host);
                                }
                            }
                        }, arrayOfJSON[ni]);
                    }

                }, '/test');

                renderer.run();
            }


        </script>

        <style type="text/css" media="screen">
            body, html, svg { width: 100%; height: 100%; overflow: hidden; }
        </style>
    </head>
    <body onload="onLoad()">

    </body>
</html>
